//
//  ContinuationCapture.swift
//  AsynchronousProgramming
//
//  Demonstrates various approaches to capturing continuation within an AsyncStream
//
//
//
//

//  Created by Phil Kirby on 2/7/25.
//

import Foundation
import SwiftUI

/* ItemGenerator
 Purpose:   Generates events
 State:
    handler:    called for each event
 Functionality:
    start():    starts event generation
    stop():     halts event generation
 */
class ItemGenerator<T> {
    private var handler: ((T) async -> Void)?
    public var worker: (() async -> Void)?
    
    init(_ handler: ((T) async -> Void)? = nil) {
        self.handler = handler
    }
    
    func start(max: Int) async {
        guard let wrk = worker else { return }
        
        await wrk()
    }
    
    func stop() {
        self.handler = nil
    }
    
    func countToMax() async {
        for i in 0..<20 {
            guard let ha = self.handler else { return }
            await ha(i as! T)
        }
    }
    
    func randomNumbers() async {
        for _ in 0..<20 {
            guard let ha = self.handler else { return }
            await ha(Int.random(in: 0..<20) as! T)
        }
    }
}

/* Service
 Purpose:   Fetches events generated by the ItemGenerator and exposes them via an AsyncStream
 Functionality:
    generateEvents():   starts event generation. returns an AsyncStream
    stopEventGeneration():  stops event generation
 */
class ItemGeneratorService : TaskCancellable {
    private var stateMachine: ItemGeneratorStateMachine = ItemGeneratorStateMachine()
    private var generator: ItemGenerator<Int>! = nil
    var task: Task<(), Never>?
    
    func generateEvents() -> AsyncStream<Int>  {
        buildStream() { [weak self] continuation in
            guard let self = self else { return }
            
            self.generator = ItemGenerator<Int> { event in
                try? await Task.sleep(for: .milliseconds(2000))
                print("event: \(event)")
                continuation.yield(event)
            }
            
            self.generator.worker = self.generator.randomNumbers
            
            self.task = Task {
                print("ItemGeneratorService.task started")
                
                await self.generator.start(max: 20)
                
                print("ItemGeneratorService.task ended")
            }
            
            print("ItemGeneratorService.task initialized")
        }
    }
    
    func stopEventGeneration() {
        generator = nil
        
        self.cancelTask(label: "ItemGeneratorService.task")
    }
    
    func buildStream(worker: (AsyncStream<Int>.Continuation) -> Void) -> AsyncStream<Int> {
        AsyncStream<Int> { continuation in
            worker(continuation)
        }
    }
    
    func generateRandomNumbers() -> AsyncStream<Int> {
        buildStream() { [weak self] continuation in
            guard let self = self else { return }
            
            self.generator = ItemGenerator<Int> { event in
                try? await Task.sleep(for: .milliseconds(2000))
                print("event: \(event)")
                continuation.yield(event)
            }
            
            self.task = Task {
                print("ItemGeneratorService.task started")
                
                await self.generator.start(max: 20)
                
                print("ItemGeneratorService.task ended")
            }
            
            print("ItemGeneratorService.task initialized")
        }
    }
}


/* View Model
 Purpose:   waits on events generated by the service.  The events are provided by an AsyncStream.
 State:
    @Published currentEvent: stores the latest event from the service
 
 Functionality:
    start():    starts event generation
    stop():     stops event generation
 */
@MainActor
class ItemGeneratorViewModel: ObservableObject, @preconcurrency TaskCancellable {
    @Published var currentEvent: Int = -1
    private let service: ItemGeneratorService? = ItemGeneratorService()
    var task: Task<(), Never>?
    
    func start() {
        print("ItemGeneratorViewModel.start() called")
        self.task = Task {
            print("ItemGeneratorViewModel.task started")
            guard let srv = service else { return }
            
            // start the event generation by calling the service
            for await event in srv.generateEvents() {
                do {
                    currentEvent = event
                }
            }
            print("ItemGeneratorViewModel.task ended")
        }
        
        print("ItemGeneratorViewModel.task initialized")
        print("ItemGeneratorViewModel.start() ended")
    }
    
    func stop() {
        print("ItemGeneratorViewModel.stop() called")
        // cancel and set task to nil
        cancelTask(label: "ItemGeneratorViewModel.task")
        
        guard let srv = service else { return }
        srv.stopEventGeneration()
        print("ItemGeneratorViewModel.stop() ended")
    }
}

/* View
 Purpose:   display the latest event in a text view
 State:
    viewModel:  ViewModel
    body:
        VStack
            Button("Start")
            Text(viewModel.counter)
            Button("Stop")
 */
struct ItemGeneratorView : View {
    @StateObject var viewModel: ItemGeneratorViewModel = ItemGeneratorViewModel()
    
    var body: some View {
        VStack {
            HStack {
                Button("Start") {
                    viewModel.start()
                }
                Button("Stop") {
                    viewModel.stop()
                }
            }
            Text("\(viewModel.currentEvent)")
        }
    }
}

/*
 Stream state tracking
 */
enum ItemGeneratorState<T> : CustomStringConvertible {
    var description: String {
        switch(self) {
        case .cancelled: return "Cancelled"
        case .completed: return "Completed"
        case .idle: return "Idle"
        default: return "Running..."
        }
    }
    
    case idle
    case running(T)
    case completed
    case cancelled
}

enum ItemGeneratorAction {
    case start
    case stop
    case finish
    case cancelled
    
    var description: String {
        switch(self) {
        case .start: return "Start"
        case .stop: return "Stop"
        case .finish: return "Finish"
        case .cancelled: return "Cancelled"
        }
    }
}

class ItemGeneratorStateMachine {
    var currentState: ItemGeneratorState<Int> = .idle
    
    func send(_ action: ItemGeneratorAction) {
        switch(action) {
        case .start:
            guard case .idle = currentState else { return }
            currentState = .running(-1)
        case .stop:
            guard case .running = currentState else { return }
            currentState = .idle
        case .finish:
            guard case .running = currentState else { return }
            currentState = .completed
        case .cancelled:
            guard case .running(let value) = currentState else { return }
            currentState = .cancelled
            print("Generator cancelled with value: \(value)")
        }
    }
}

var closure: ((Int?) -> Void)?

let sequence = AsyncStream<Int> { continuation in
    closure = {
        if let value = $0 {
            continuation.yield(value)
        } else {
            continuation.finish()
        }
    }
}
